{
  "version": 3,
  "sources": ["../../blobs/internal/util.ts", "../../blobs/internal/rand.ts", "../../blobs/internal/gen.ts", "../../blobs/internal/animate/timing.ts", "../../blobs/internal/animate/prepare.ts", "../../blobs/internal/animate/interpolate.ts", "../../blobs/internal/animate/frames.ts", "../../blobs/internal/check.ts", "../../blobs/internal/animate/state.ts", "../../blobs/public/animate.ts", "../../blobs/internal/render/canvas.ts"],
  "sourcesContent": ["import {Coord, Handle, Point} from \"./types\";\n\nexport const copyPoint = (p: Point): Point => ({\n    x: p.x,\n    y: p.y,\n    handleIn: {...p.handleIn},\n    handleOut: {...p.handleOut},\n});\n\nexport interface PointIteratorArgs {\n    curr: Point;\n    index: number;\n    sibling: (pos: number) => Point;\n    prev: () => Point;\n    next: () => Point;\n}\n\nexport const coordPoint = (coord: Coord): Point => {\n    return {\n        ...coord,\n        handleIn: {angle: 0, length: 0},\n        handleOut: {angle: 0, length: 0},\n    };\n};\n\nexport const forPoints = (points: Point[], callback: (args: PointIteratorArgs) => void) => {\n    for (let i = 0; i < points.length; i++) {\n        const sibling = (pos: number) => copyPoint(points[mod(pos, points.length)]);\n        callback({\n            curr: copyPoint(points[i]),\n            index: i,\n            sibling,\n            prev: () => sibling(i - 1),\n            next: () => sibling(i + 1),\n        });\n    }\n};\n\nexport const mapPoints = (\n    points: Point[],\n    callback: (args: PointIteratorArgs) => Point,\n): Point[] => {\n    const out: Point[] = [];\n    forPoints(points, (args) => {\n        out.push(callback(args));\n    });\n    return out;\n};\n\nexport const coordEqual = (a: Coord, b: Coord): boolean => {\n    return a.x === b.x && a.y === b.y;\n};\n\nexport const angleOf = (a: Coord, b: Coord): number => {\n    const dx = b.x - a.x;\n    const dy = -b.y + a.y;\n    const angle = Math.atan2(dy, dx);\n    if (angle < 0) {\n        return Math.abs(angle);\n    } else {\n        return 2 * Math.PI - angle;\n    }\n};\n\nexport const expandHandle = (point: Coord, handle: Handle): Coord => ({\n    x: point.x + handle.length * Math.cos(handle.angle),\n    y: point.y + handle.length * Math.sin(handle.angle),\n});\n\nconst collapseHandle = (point: Coord, handle: Coord): Handle => ({\n    angle: angleOf(point, handle),\n    length: Math.sqrt((handle.x - point.x) ** 2 + (handle.y - point.y) ** 2),\n});\n\nexport const length = (a: Point, b: Point): number => {\n    const aHandle = expandHandle(a, a.handleOut);\n    const bHandle = expandHandle(b, b.handleIn);\n    const ab = distance(a, b);\n    const abHandle = distance(aHandle, bHandle);\n    return (ab + abHandle + a.handleOut.length + b.handleIn.length) / 2;\n};\n\nexport const reverse = (points: Point[]): Point[] => {\n    return mapPoints(points, ({index, sibling}) => {\n        const point = sibling(points.length - index - 1);\n        point.handleIn.angle += Math.PI;\n        point.handleOut.angle += Math.PI;\n        return point;\n    });\n};\n\nexport const shift = (offset: number, points: Point[]): Point[] => {\n    return mapPoints(points, ({index, sibling}) => {\n        return sibling(index + offset);\n    });\n};\n\n// Add a control point to the curve between a and b.\n// Percentage [0, 1] from a to b.\n// a: original first point.\n// b: original last point.\n// c: new first point.\n// d: new added point.\n// e: new last point.\n// f: split point between a and b's handles.\n// g: split point between c's handle and f.\n// h: split point between e's handle and f.\nexport const insertAt = (percentage: number, a: Point, b: Point): [Point, Point, Point] => {\n    const c = copyPoint(a);\n    c.handleOut.length *= percentage;\n\n    const e = copyPoint(b);\n    e.handleIn.length *= 1 - percentage;\n\n    const aHandle = expandHandle(a, a.handleOut);\n    const bHandle = expandHandle(b, b.handleIn);\n    const cHandle = expandHandle(c, c.handleOut);\n    const eHandle = expandHandle(e, e.handleIn);\n    const f = splitLine(percentage, aHandle, bHandle);\n    const g = splitLine(percentage, cHandle, f);\n    const h = splitLine(1 - percentage, eHandle, f);\n    const dCoord = splitLine(percentage, g, h);\n\n    const d: Point = {\n        x: dCoord.x,\n        y: dCoord.y,\n        handleIn: collapseHandle(dCoord, g),\n        handleOut: collapseHandle(dCoord, h),\n    };\n    return [c, d, e];\n};\n\nexport const insertCount = (count: number, a: Point, b: Point): Point[] => {\n    if (count < 2) return [a, b];\n    const percentage = 1 / count;\n    const [c, d, e] = insertAt(percentage, a, b);\n    if (count === 2) return [c, d, e];\n    return [c, ...insertCount(count - 1, d, e)];\n};\n\n// Smooths out the path made up of the given points.\n// Existing handles are ignored.\nexport const smooth = (points: Point[], strength: number): Point[] => {\n    return mapPoints(points, ({curr, next, prev}) => {\n        const angle = angleOf(prev(), next());\n        return {\n            x: curr.x,\n            y: curr.y,\n            handleIn: {\n                angle: angle + Math.PI,\n                length: strength * distance(curr, prev()),\n            },\n            handleOut: {\n                angle,\n                length: strength * distance(curr, next()),\n            },\n        };\n    });\n};\n\n// Modulo operation that always produces a positive result.\n// https://stackoverflow.com/q/4467539/3053361\nexport const mod = (a: number, n: number): number => {\n    return ((a % n) + n) % n;\n};\n\n// Converts degrees to radians.\nexport const rad = (deg: number) => {\n    return (deg / 360) * 2 * Math.PI;\n};\n\n// Converts radians to degrees.\nexport const deg = (rad: number) => {\n    return (((rad / Math.PI) * 1) / 2) * 360;\n};\n\n// Calculates distance between two points.\nexport const distance = (a: Coord, b: Coord): number => {\n    return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);\n};\n\n// Calculates the angle of the line from a to b in degrees.\nexport const angle = (a: Coord, b: Coord): number => {\n    return deg(Math.atan2(b.y - a.y, b.x - a.x));\n};\n\nexport const split = (percentage: number, a: number, b: number): number => {\n    return a + percentage * (b - a);\n};\n\nexport const splitLine = (percentage: number, a: Coord, b: Coord): Coord => {\n    return {\n        x: split(percentage, a.x, b.x),\n        y: split(percentage, a.y, b.y),\n    };\n};\n", "// Seeded random number generator.\n// https://stackoverflow.com/a/47593316/3053361\nexport const rand = (seed: string) => {\n    const xfnv1a = (str: string) => {\n        let h = 2166136261 >>> 0;\n        for (let i = 0; i < str.length; i++) {\n            h = Math.imul(h ^ str.charCodeAt(i), 16777619);\n        }\n        return () => {\n            h += h << 13;\n            h ^= h >>> 7;\n            h += h << 3;\n            h ^= h >>> 17;\n            return (h += h << 5) >>> 0;\n        };\n    };\n\n    const sfc32 = (a: number, b: number, c: number, d: number) => () => {\n        a >>>= 0;\n        b >>>= 0;\n        c >>>= 0;\n        d >>>= 0;\n        var t = (a + b) | 0;\n        a = b ^ (b >>> 9);\n        b = (c + (c << 3)) | 0;\n        c = (c << 21) | (c >>> 11);\n        d = (d + 1) | 0;\n        t = (t + d) | 0;\n        c = (c + t) | 0;\n        return (t >>> 0) / 4294967296;\n    };\n\n    const seedGenerator = xfnv1a(seed);\n    return sfc32(seedGenerator(), seedGenerator(), seedGenerator(), seedGenerator());\n};\n", "import {rand} from \"../internal/rand\";\nimport {mapPoints} from \"../internal/util\";\nimport {BlobOptions} from \"../public/blobs\";\nimport {Point} from \"./types\";\nimport {smooth} from \"./util\";\n\nexport const genBlob = (pointCount: number, offset: () => number): Point[] => {\n    const angle = (Math.PI * 2) / pointCount;\n\n    const points: Point[] = [];\n    for (let i = 0; i < pointCount; i++) {\n        const randPointOffset = offset();\n        const pointX = Math.sin(i * angle);\n        const pointY = Math.cos(i * angle);\n        points.push({\n            x: 0.5 + pointX * randPointOffset,\n            y: 0.5 + pointY * randPointOffset,\n            handleIn: {angle: 0, length: 0},\n            handleOut: {angle: 0, length: 0},\n        });\n    }\n\n    // https://math.stackexchange.com/a/873589/235756\n    const smoothingStrength = ((4 / 3) * Math.tan(angle / 4)) / Math.sin(angle / 2) / 2;\n\n    return smooth(points, smoothingStrength);\n};\n\nexport const genFromOptions = (blobOptions: BlobOptions): Point[] => {\n    const rgen = rand(String(blobOptions.seed));\n\n    // Scale of random movement increases as randomness approaches infinity.\n    // randomness = 0   -> rangeStart = 1\n    // randomness = 2   -> rangeStart = 0.8333\n    // randomness = 5   -> rangeStart = 0.6667\n    // randomness = 10  -> rangeStart = 0.5\n    // randomness = 20  -> rangeStart = 0.3333\n    // randomness = 50  -> rangeStart = 0.1667\n    // randomness = 100 -> rangeStart = 0.0909\n    const rangeStart = 1 / (1 + blobOptions.randomness / 10);\n\n    const points = genBlob(\n        3 + blobOptions.extraPoints,\n        () => (rangeStart + rgen() * (1 - rangeStart)) / 2,\n    );\n\n    const size = blobOptions.size;\n    return mapPoints(points, ({curr}) => {\n        curr.x *= size;\n        curr.y *= size;\n        curr.handleIn.length *= size;\n        curr.handleOut.length *= size;\n        return curr;\n    });\n};\n", "export interface TimingFunc {\n    (percentage: number): number;\n}\n\nconst linear: TimingFunc = (p) => {\n    return p;\n};\n\nconst easeEnd: TimingFunc = (p) => {\n    return 1 - (p - 1) ** 2;\n};\n\nconst easeStart: TimingFunc = (p) => {\n    return 1 - easeEnd(1 - p);\n};\n\nconst ease: TimingFunc = (p) => {\n    return 0.5 + 0.5 * Math.sin(Math.PI * (p + 1.5));\n};\n\nconst elasticEnd = (s: number): TimingFunc => (p) => {\n    return Math.pow(2, -10 * p) * Math.sin(((p - s / 4) * (2 * Math.PI)) / s) + 1;\n};\n\n// https://www.desmos.com/calculator/fqisoq1kuw\nexport const timingFunctions = {\n    linear,\n    easeEnd,\n    easeStart,\n    ease,\n    elasticEnd0: elasticEnd(1),\n    elasticEnd1: elasticEnd(0.64),\n    elasticEnd2: elasticEnd(0.32),\n    elasticEnd3: elasticEnd(0.16),\n};\n\n// @ts-ignore: Type assertion.\nconst _: Record<string, TimingFunc> = timingFunctions;\n", "import {\n    length,\n    reverse,\n    shift,\n    insertCount,\n    distance,\n    mod,\n    angleOf,\n    coordEqual,\n    mapPoints,\n    forPoints,\n} from \"../util\";\nimport {Point} from \"../types\";\n\nconst optimizeOrder = (a: Point[], b: Point[]): Point[] => {\n    const count = a.length;\n\n    let minTotal = Infinity;\n    let minOffset = 0;\n    let minOffsetBase: Point[] = [];\n\n    const setMinOffset = (points: Point[]) => {\n        for (let i = 0; i < count; i++) {\n            let total = 0;\n            for (let j = 0; j < count; j++) {\n                total += (100 * distance(a[j], points[mod(j + i, count)])) ** 2;\n                if (total > minTotal) break;\n            }\n            if (total <= minTotal) {\n                minTotal = total;\n                minOffset = i;\n                minOffsetBase = points;\n            }\n        }\n    };\n    setMinOffset(b);\n    setMinOffset(reverse(b));\n\n    return shift(minOffset, minOffsetBase);\n};\n\nexport const divide = (count: number, points: Point[]): Point[] => {\n    if (points.length < 3) throw new Error(\"not enough points\");\n    if (count < points.length) throw new Error(\"cannot remove points\");\n    if (count === points.length) return points.slice();\n\n    const lengths: number[] = [];\n    forPoints(points, ({curr, next}) => {\n        lengths.push(length(curr, next()));\n    });\n\n    const divisors = divideLengths(lengths, count - points.length);\n    const out: Point[] = [];\n    for (let i = 0; i < points.length; i++) {\n        const curr: Point = out[out.length - 1] || points[i];\n        const next = points[mod(i + 1, points.length)];\n        out.pop();\n        out.push(...insertCount(divisors[i], curr, next));\n    }\n    const last = out.pop();\n    out[0].handleIn = last!.handleIn;\n\n    return out;\n};\n\n// If point has no handle and is on top of the point before or after it, use the\n// angle of the fixer shape's point at the same index. This is especially useful\n// when all the points of the initial shape are concentrated on the same\n// coordinates and \"expand\" into the target shape.\nconst fixAnglesWith = (fixee: Point[], fixer: Point[]): Point[] => {\n    return mapPoints(fixee, ({index, curr, prev, next}) => {\n        if (curr.handleIn.length === 0 && coordEqual(prev(), curr)) {\n            curr.handleIn.angle = fixer[index].handleIn.angle;\n        }\n        if (curr.handleOut.length === 0 && coordEqual(next(), curr)) {\n            curr.handleOut.angle = fixer[index].handleOut.angle;\n        }\n        return curr;\n    });\n};\n\n// If point has no handle, use angle between before and after points.\nconst fixAnglesSelf = (points: Point[]): Point[] => {\n    return mapPoints(points, ({curr, prev, next}) => {\n        const angle = angleOf(prev(), next());\n        if (curr.handleIn.length === 0) {\n            curr.handleIn.angle = angle + Math.PI;\n        }\n        if (curr.handleOut.length === 0) {\n            curr.handleOut.angle = angle;\n        }\n        return curr;\n    });\n};\n\nconst divideLengths = (lengths: number[], add: number): number[] => {\n    const divisors = lengths.map(() => 1);\n    const sizes = lengths.slice();\n    for (let i = 0; i < add; i++) {\n        let maxSizeIndex = 0;\n        for (let j = 1; j < sizes.length; j++) {\n            if (sizes[j] > sizes[maxSizeIndex]) {\n                maxSizeIndex = j;\n                continue;\n            }\n            if (sizes[j] === sizes[maxSizeIndex]) {\n                if (lengths[j] > lengths[maxSizeIndex]) {\n                    maxSizeIndex = j;\n                }\n            }\n        }\n        divisors[maxSizeIndex]++;\n        sizes[maxSizeIndex] = lengths[maxSizeIndex] / divisors[maxSizeIndex];\n    }\n    return divisors;\n};\n\nexport const prepare = (\n    a: Point[],\n    b: Point[],\n    options: {rawAngles: boolean; divideRatio: number},\n): [Point[], Point[]] => {\n    const pointCount = options.divideRatio * Math.max(a.length, b.length);\n    const aNorm = divide(pointCount, a);\n    const bNorm = divide(pointCount, b);\n    const bOpt = optimizeOrder(aNorm, bNorm);\n    return [\n        options.rawAngles ? aNorm : fixAnglesWith(fixAnglesSelf(aNorm), bOpt),\n        options.rawAngles ? bOpt : fixAnglesWith(fixAnglesSelf(bOpt), aNorm),\n    ];\n};\n", "import {Point} from \"../types\";\nimport {split, splitLine, mod, smooth, mapPoints} from \"../util\";\n\n// Interpolates between angles a and b. Angles are normalized to avoid unnecessary rotation.\n// Direction is chosen to produce the smallest possible movement.\nconst interpolateAngle = (percentage: number, a: number, b: number): number => {\n    const tau = Math.PI * 2;\n    let aNorm = mod(a, tau);\n    let bNorm = mod(b, tau);\n    if (Math.abs(aNorm - bNorm) > Math.PI) {\n        if (aNorm < bNorm) {\n            aNorm += tau;\n        } else {\n            bNorm += tau;\n        }\n    }\n    return split(percentage, aNorm, bNorm);\n};\n\n// Interpolates linearly between a and b. Can only interpolate between point lists that have the\n// same number of points. Easing effects can be applied to the percentage given to this function.\n// Percentages outside the 0-1 range are supported.\nexport const interpolateBetween = (percentage: number, a: Point[], b: Point[]): Point[] => {\n    if (a.length !== b.length) throw new Error(\"must have equal number of points\");\n\n    // Clamped range for use in values that could look incorrect otherwise.\n    // ex. Handles that invert if their value goes negative (creates loops at corners).\n    const clamped = Math.min(1, Math.max(0, percentage));\n\n    const points: Point[] = [];\n    for (let i = 0; i < a.length; i++) {\n        points.push({\n            ...splitLine(percentage, a[i], b[i]),\n            handleIn: {\n                angle: interpolateAngle(percentage, a[i].handleIn.angle, b[i].handleIn.angle),\n                length: split(clamped, a[i].handleIn.length, b[i].handleIn.length),\n            },\n            handleOut: {\n                angle: interpolateAngle(percentage, a[i].handleOut.angle, b[i].handleOut.angle),\n                length: split(clamped, a[i].handleOut.length, b[i].handleOut.length),\n            },\n        });\n    }\n    return points;\n};\n\n// Interpolates between a and b while applying a smoothing effect. Smoothing effect's strength is\n// relative to how far away the percentage is from either 0 or 1. It is strongest in the middle of\n// the animation (percentage = 0.5) or when bounds are exceeded (percentage = 1.8).\nexport const interpolateBetweenSmooth = (\n    strength: number,\n    percentage: number,\n    a: Point[],\n    b: Point[],\n): Point[] => {\n    strength *= Math.min(1, Math.min(Math.abs(0 - percentage), Math.abs(1 - percentage)));\n    const interpolated = interpolateBetween(percentage, a, b);\n    const smoothed = smooth(interpolated, Math.sqrt(strength + 0.25) / 3);\n    return mapPoints(interpolated, ({index, curr}) => {\n        const sp = smoothed[index];\n        curr.handleIn.angle = interpolateAngle(strength, curr.handleIn.angle, sp.handleIn.angle);\n        curr.handleIn.length = split(strength, curr.handleIn.length, sp.handleIn.length);\n        curr.handleOut.angle = interpolateAngle(strength, curr.handleOut.angle, sp.handleOut.angle);\n        curr.handleOut.length = split(strength, curr.handleOut.length, sp.handleOut.length);\n        return curr;\n    });\n};\n", "import {TimingFunc, timingFunctions} from \"./timing\";\nimport {Point} from \"../types\";\nimport {prepare} from \"./prepare\";\nimport {interpolateBetween} from \"./interpolate\";\n\nexport interface Keyframe {\n    delay?: number;\n    duration: number;\n    timingFunction?: keyof typeof timingFunctions;\n}\n\nexport interface InternalKeyframe {\n    id: string;\n    timestamp: number;\n    timingFunction: TimingFunc;\n    initialPoints: Point[];\n    transitionSourceFrameIndex: number;\n    isSynthetic: boolean;\n}\n\nexport interface RenderCache {\n    [frameId: string]: {\n        preparedEndPoints?: Point[];\n        preparedStartPoints?: Point[];\n    };\n}\n\nexport interface RenderInput {\n    currentFrames: InternalKeyframe[];\n    timestamp: number;\n    renderCache: RenderCache;\n}\n\nexport interface RenderOutput {\n    points: Point[];\n    lastFrameId: string | null;\n    renderCache: RenderCache;\n}\n\nexport interface TransitionInput<T extends Keyframe> extends RenderInput {\n    newFrames: T[];\n    shapeGenerator: (keyframe: T) => Point[];\n}\n\nexport interface TransitionOutput {\n    newFrames: InternalKeyframe[];\n}\n\nconst genId = (): string => {\n    return String(Math.random()).substr(2);\n};\n\nexport const renderFramesAt = (input: RenderInput): RenderOutput => {\n    const {renderCache, currentFrames} = input;\n\n    if (currentFrames.length === 0) {\n        return {renderCache, lastFrameId: null, points: []};\n    }\n\n    // Animation freezes at the final shape if there are no more keyframes.\n    if (currentFrames.length === 1) {\n        const first = currentFrames[0];\n        return {renderCache, lastFrameId: first.id, points: first.initialPoints};\n    }\n\n    // Find the start/end keyframes according to the timestamp.\n    let startKeyframe = currentFrames[0];\n    let endKeyframe = currentFrames[1];\n    for (let i = 2; i < currentFrames.length; i++) {\n        if (endKeyframe.timestamp > input.timestamp) break;\n        startKeyframe = currentFrames[i - 1];\n        endKeyframe = currentFrames[i];\n    }\n\n    // Return original end shape when past the end of the animation.\n    const endKeyframeIsLast = endKeyframe === currentFrames[currentFrames.length - 1];\n    const animationIsPastEndKeyframe = endKeyframe.timestamp < input.timestamp;\n    if (animationIsPastEndKeyframe && endKeyframeIsLast) {\n        return {\n            renderCache,\n            lastFrameId: endKeyframe.id,\n            points: endKeyframe.initialPoints,\n        };\n    }\n\n    // Use and cache prepared points for current interpolation.\n    let preparedStartPoints: Point[] | undefined =\n        renderCache[startKeyframe.id]?.preparedStartPoints;\n    let preparedEndPoints: Point[] | undefined = renderCache[endKeyframe.id]?.preparedEndPoints;\n    if (!preparedStartPoints || !preparedEndPoints) {\n        [preparedStartPoints, preparedEndPoints] = prepare(\n            startKeyframe.initialPoints,\n            endKeyframe.initialPoints,\n            {rawAngles: false, divideRatio: 1},\n        );\n\n        renderCache[startKeyframe.id] = renderCache[startKeyframe.id] || {};\n        renderCache[startKeyframe.id].preparedStartPoints = preparedStartPoints;\n\n        renderCache[endKeyframe.id] = renderCache[endKeyframe.id] || {};\n        renderCache[endKeyframe.id].preparedEndPoints = preparedEndPoints;\n    }\n\n    // Calculate progress between frames as a fraction.\n    const progress =\n        (input.timestamp - startKeyframe.timestamp) /\n        (endKeyframe.timestamp - startKeyframe.timestamp);\n\n    // Keep progress within expected range (ex. division by 0).\n    const clampedProgress = Math.max(0, Math.min(1, progress));\n\n    // Apply timing function of end frame.\n    const adjustedProgress = endKeyframe.timingFunction(clampedProgress);\n\n    return {\n        renderCache,\n        lastFrameId: clampedProgress === 1 ? endKeyframe.id : startKeyframe.id,\n        points: interpolateBetween(adjustedProgress, preparedStartPoints, preparedEndPoints),\n    };\n};\n\nexport const transitionFrames = <T extends Keyframe>(\n    input: TransitionInput<T>,\n): TransitionOutput => {\n    // Erase all old frames.\n    const newInternalFrames: InternalKeyframe[] = [];\n\n    // Reset animation when given no keyframes.\n    if (input.newFrames.length === 0) {\n        return {newFrames: newInternalFrames};\n    }\n\n    // Add current state as initial frame.\n    const currentState = renderFramesAt(input);\n    if (currentState.lastFrameId === null) {\n        // If there is currently no shape being rendered, use a point in the\n        // center of the next frame as the initial point.\n        const firstShape = input.shapeGenerator(input.newFrames[0]);\n        let firstShapeCenterPoint: Point = {\n            x: 0,\n            y: 0,\n            handleIn: {angle: 0, length: 0},\n            handleOut: {angle: 0, length: 0},\n        };\n        for (const point of firstShape) {\n            firstShapeCenterPoint.x += point.x / firstShape.length;\n            firstShapeCenterPoint.y += point.y / firstShape.length;\n        }\n        currentState.points = [firstShapeCenterPoint, firstShapeCenterPoint, firstShapeCenterPoint];\n    }\n    newInternalFrames.push({\n        id: genId(),\n        initialPoints: currentState.points,\n        timestamp: input.timestamp,\n        timingFunction: timingFunctions.linear,\n        transitionSourceFrameIndex: -1,\n        isSynthetic: true,\n    });\n\n    // Generate and add new frames.\n    let totalOffset = 0;\n    for (let i = 0; i < input.newFrames.length; i++) {\n        const keyframe = input.newFrames[i];\n\n        // Copy previous frame when current one has a delay.\n        if (keyframe.delay) {\n            totalOffset += keyframe.delay;\n            const prevFrame = newInternalFrames[newInternalFrames.length - 1];\n            newInternalFrames.push({\n                id: genId(),\n                initialPoints: prevFrame.initialPoints,\n                timestamp: input.timestamp + totalOffset,\n                timingFunction: timingFunctions.linear,\n                transitionSourceFrameIndex: i - 1,\n                isSynthetic: true,\n            });\n        }\n\n        totalOffset += keyframe.duration;\n        newInternalFrames.push({\n            id: genId(),\n            initialPoints: input.shapeGenerator(keyframe),\n            timestamp: input.timestamp + totalOffset,\n            timingFunction: timingFunctions[keyframe.timingFunction || \"linear\"],\n            transitionSourceFrameIndex: i,\n            isSynthetic: false,\n        });\n    }\n\n    return {newFrames: newInternalFrames};\n};\n", "import {timingFunctions} from \"./animate/timing\";\n\nconst typeCheck = (name: string, val: any, expected: string[]) => {\n    let actual: string = typeof val;\n    if (actual === \"number\" && isNaN(val)) actual = \"NaN\";\n    if (actual === \"object\" && val === null) actual = \"null\";\n    if (!expected.includes(actual)) {\n        throw `\"${name}\" should have type \"${expected.join(\"|\")}\" but was \"${actual}\".`;\n    }\n};\n\nexport const checkKeyframeOptions = (keyframe: any) => {\n    typeCheck(`keyframe`, keyframe, [\"object\"]);\n    const {delay, duration, timingFunction, callback} = keyframe;\n    typeCheck(`delay`, delay, [\"number\", \"undefined\"]);\n    if (delay && delay < 0) throw `delay is invalid \"${delay}\".`;\n    typeCheck(`duration`, duration, [\"number\"]);\n    if (duration && duration < 0) throw `duration is invalid \"${duration}\".`;\n    typeCheck(`timingFunction`, timingFunction, [\"string\", \"undefined\"]);\n    if (timingFunction && !(timingFunctions as any)[timingFunction])\n        throw `\".timingFunction\" is not recognized \"${timingFunction}\".`;\n    typeCheck(`callback`, callback, [\"function\", \"undefined\"]);\n};\n\nexport const checkBlobOptions = (blobOptions: any) => {\n    typeCheck(`blobOptions`, blobOptions, [\"object\"]);\n    const {seed, extraPoints, randomness, size} = blobOptions;\n    typeCheck(`blobOptions.seed`, seed, [\"string\", \"number\"]);\n    typeCheck(`blobOptions.extraPoints`, extraPoints, [\"number\"]);\n    if (extraPoints < 0) throw `blobOptions.extraPoints is invalid \"${extraPoints}\".`;\n    typeCheck(`blobOptions.randomness`, randomness, [\"number\"]);\n    if (randomness < 0) throw `blobOptions.randomness is invalid \"${randomness}\".`;\n    typeCheck(`blobOptions.size`, size, [\"number\"]);\n    if (size < 0) throw `blobOptions.size is invalid \"${size}\".`;\n};\n\nexport const checkCanvasOptions = (canvasOptions: any) => {\n    typeCheck(`canvasOptions`, canvasOptions, [\"object\", \"undefined\"]);\n    if (canvasOptions) {\n        const {offsetX, offsetY} = canvasOptions;\n        typeCheck(`canvasOptions.offsetX`, offsetX, [\"number\", \"undefined\"]);\n        typeCheck(`canvasOptions.offsetY`, offsetY, [\"number\", \"undefined\"]);\n    }\n};\n\nexport const checkSvgOptions = (svgOptions: any) => {\n    typeCheck(`svgOptions`, svgOptions, [\"object\", \"undefined\"]);\n    if (svgOptions) {\n        const {fill, stroke, strokeWidth} = svgOptions;\n        typeCheck(`svgOptions.fill`, fill, [\"string\", \"undefined\"]);\n        typeCheck(`svgOptions.stroke`, stroke, [\"string\", \"undefined\"]);\n        typeCheck(`svgOptions.strokeWidth`, strokeWidth, [\"number\", \"undefined\"]);\n    }\n};\n", "import {Point} from \"../types\";\nimport {RenderCache, InternalKeyframe, renderFramesAt, transitionFrames, Keyframe} from \"./frames\";\n\ninterface CallbackKeyframe extends Keyframe {\n    callback?: () => void;\n}\n\ninterface CallbackStore {\n    [frameId: string]: () => void;\n}\n\nexport const statefulAnimationGenerator = <K extends CallbackKeyframe, T>(\n    generator: (keyframe: K) => Point[],\n    renderer: (points: Point[]) => T,\n    checker: (keyframe: K, index: number) => void,\n) => () => {\n    let internalFrames: InternalKeyframe[] = [];\n    let renderCache: RenderCache = {};\n    let callbackStore: CallbackStore = {};\n\n    // Keep track of paused state.\n    let pausedAt = 0;\n    let pauseOffset = 0;\n    const getAnimationTimestamp = () => Date.now() - pauseOffset;\n    const isPaused = () => pausedAt !== 0;\n\n    const play = () => {\n        if (!isPaused()) return;\n        pauseOffset += getAnimationTimestamp() - pausedAt;\n        pausedAt = 0;\n    };\n\n    const pause = () => {\n        if (isPaused()) return;\n        pausedAt = getAnimationTimestamp();\n    };\n\n    const playPause = () => {\n        ``;\n        if (isPaused()) {\n            play();\n        } else {\n            pause();\n        }\n    };\n\n    const renderFrame = (): T => {\n        const renderOutput = renderFramesAt({\n            renderCache: renderCache,\n            timestamp: isPaused() ? pausedAt : getAnimationTimestamp(),\n            currentFrames: internalFrames,\n        });\n\n        // Update render cache with returned value.\n        renderCache = renderOutput.renderCache;\n\n        // Invoke callback if defined and the first time the frame is reached.\n        if (renderOutput.lastFrameId && callbackStore[renderOutput.lastFrameId]) {\n            callbackStore[renderOutput.lastFrameId]();\n            delete callbackStore[renderOutput.lastFrameId];\n        }\n\n        return renderer(renderOutput.points);\n    };\n\n    const transition = (...keyframes: K[]) => {\n        // Make sure frame info is valid.\n        for (let i = 0; i < keyframes.length; i++) {\n            checker(keyframes[i], i);\n        }\n\n        const transitionOutput = transitionFrames<K>({\n            renderCache: renderCache,\n            timestamp: getAnimationTimestamp(),\n            currentFrames: internalFrames,\n            newFrames: keyframes,\n            shapeGenerator: generator,\n        });\n\n        // Reset internal state..\n        internalFrames = transitionOutput.newFrames;\n        callbackStore = {};\n        renderCache = {};\n\n        // Populate callback store using returned frame ids.\n        for (const newFrame of internalFrames) {\n            if (newFrame.isSynthetic) continue;\n            const {callback} = keyframes[newFrame.transitionSourceFrameIndex];\n            if (callback) callbackStore[newFrame.id] = callback;\n        }\n    };\n\n    return {renderFrame, transition, play, pause, playPause};\n};\n", "import {Point} from \"../internal/types\";\nimport {renderPath2D} from \"../internal/render/canvas\";\nimport {genFromOptions} from \"../internal/gen\";\nimport {mapPoints} from \"../internal/util\";\nimport {statefulAnimationGenerator} from \"../internal/animate/state\";\nimport {checkBlobOptions, checkCanvasOptions, checkKeyframeOptions} from \"../internal/check\";\n\nexport interface CanvasKeyframe {\n    delay?: number;\n    duration: number;\n    timingFunction?:\n        | \"linear\"\n        | \"easeEnd\"\n        | \"easeStart\"\n        | \"ease\"\n        | \"elasticEnd0\"\n        | \"elasticEnd1\"\n        | \"elasticEnd2\"\n        | \"elasticEnd3\";\n    callback?: () => void;\n    blobOptions: {\n        seed: number | string;\n        randomness: number;\n        extraPoints: number;\n        size: number;\n    };\n    canvasOptions?: {\n        offsetX?: number;\n        offsetY?: number;\n    };\n}\n\nconst canvasBlobGenerator = (keyframe: CanvasKeyframe): Point[] => {\n    return mapPoints(genFromOptions(keyframe.blobOptions), ({curr}) => {\n        curr.x += keyframe?.canvasOptions?.offsetX || 0;\n        curr.y += keyframe?.canvasOptions?.offsetY || 0;\n        return curr;\n    });\n};\n\nconst canvasKeyframeChecker = (keyframe: CanvasKeyframe, index: number) => {\n    try {\n        checkBlobOptions(keyframe.blobOptions);\n        checkCanvasOptions(keyframe.canvasOptions);\n        checkKeyframeOptions(keyframe);\n    } catch (e) {\n        throw `(blobs2): keyframe ${index}: ${e}`;\n    }\n};\n\nexport const canvasPath = statefulAnimationGenerator(\n    canvasBlobGenerator,\n    renderPath2D,\n    canvasKeyframeChecker,\n);\n", "import {Coord, Point} from \"../types\";\nimport {expandHandle, forPoints} from \"../util\";\n\nconst pointSize = 2;\nconst infoSpacing = 20;\n\nexport const clear = (ctx: CanvasRenderingContext2D) => {\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n};\n\nexport const drawInfo = (ctx: CanvasRenderingContext2D, pos: number, label: string, value: any) => {\n    ctx.fillText(`${label}: ${value}`, infoSpacing, (pos + 1) * infoSpacing);\n};\n\nconst drawLine = (ctx: CanvasRenderingContext2D, a: Coord, b: Coord, style: string) => {\n    const backupStrokeStyle = ctx.strokeStyle;\n    ctx.beginPath();\n    ctx.moveTo(a.x, a.y);\n    ctx.lineTo(b.x, b.y);\n    ctx.strokeStyle = style;\n    ctx.stroke();\n    ctx.strokeStyle = backupStrokeStyle;\n};\n\nconst drawPoint = (ctx: CanvasRenderingContext2D, p: Coord, style: string) => {\n    const backupFillStyle = ctx.fillStyle;\n    ctx.beginPath();\n    ctx.arc(p.x, p.y, pointSize, 0, 2 * Math.PI);\n    ctx.fillStyle = style;\n    ctx.fill();\n    ctx.fillStyle = backupFillStyle;\n};\n\nexport const drawClosed = (ctx: CanvasRenderingContext2D, debug: boolean, points: Point[]) => {\n    if (points.length < 2) throw new Error(\"not enough points\");\n\n    // Draw debug points.\n    if (debug) {\n        forPoints(points, ({curr, next: getNext}) => {\n            const next = getNext();\n\n            // Compute coordinates of handles.\n            const currHandle = expandHandle(curr, curr.handleOut);\n            const nextHandle = expandHandle(next, next.handleIn);\n\n            drawPoint(ctx, curr, \"\");\n            drawLine(ctx, curr, currHandle, \"#ccc\");\n            drawLine(ctx, next, nextHandle, \"#b6b\");\n        });\n    }\n\n    ctx.stroke(renderPath2D(points));\n};\n\nexport const renderPath2D = (points: Point[]): Path2D => {\n    const path = new Path2D();\n\n    if (points.length < 1) return path;\n    path.moveTo(points[0].x, points[0].y);\n\n    forPoints(points, ({curr, next: getNext}) => {\n        const next = getNext();\n        const currHandle = expandHandle(curr, curr.handleOut);\n        const nextHandle = expandHandle(next, next.handleIn);\n        path.bezierCurveTo(currHandle.x, currHandle.y, nextHandle.x, nextHandle.y, next.x, next.y);\n    });\n\n    return path;\n};\n"],
  "mappings": "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",
  "names": ["copyPoint", "p", "x", "y", "handleIn", "handleOut", "forPoints", "points", "callback", "n", "i", "sibling", "pos", "mod", "length", "curr", "index", "prev", "next", "mapPoints", "out", "args", "push", "coordEqual", "a", "b", "angleOf", "dx", "dy", "angle", "Math", "atan2", "abs", "PI", "expandHandle", "point", "handle", "cos", "sin", "collapseHandle", "sqrt", "split", "percentage", "rand", "seed", "c", "d", "seedGenerator", "str", "h", "imul", "charCodeAt", "t", "genBlob", "pointCount", "offset", "randPointOffset", "pointX", "pointY", "strength", "smoothingStrength", "tan", "_a", "distance", "easeEnd", "elasticEnd", "s", "pow", "optimizeOrder", "setMinOffset", "count", "total", "j", "minTotal", "minOffset", "minOffsetBase", "Infinity", "divide", "Error", "slice", "lengths", "aHandle", "bHandle", "divisors", "divideLengths", "pop", "insertCount", "last", "fixAnglesWith", "fixee", "fixer", "fixAnglesSelf", "interpolateAngle", "tau", "aNorm", "bNorm", "genId", "String", "random", "substr", "renderFramesAt", "input", "renderCache", "currentFrames", "lastFrameId", "first", "id", "initialPoints", "startKeyframe", "endKeyframe", "timestamp", "endKeyframeIsLast", "options", "bOpt", "preparedStartPoints", "preparedEndPoints", "divideRatio", "max", "rawAngles", "progress", "clampedProgress", "min", "adjustedProgress", "timingFunction", "clamped", "splitLine", "typeCheck", "name", "val", "expected", "actual", "isNaN", "includes", "join", "generator", "renderer", "checker", "e", "cHandle", "eHandle", "f", "g", "dCoord", "timingFunctions", "linear", "easeStart", "ease", "elasticEnd0", "elasticEnd1", "elasticEnd2", "elasticEnd3", "add", "map", "sizes", "maxSizeIndex", "canvasPath", "keyframe", "blobOptions", "rgen", "rangeStart", "randomness", "extraPoints", "size", "canvasOptions", "offsetX", "offsetY", "path", "Path2D", "moveTo", "getNext", "currHandle", "nextHandle", "bezierCurveTo", "delay", "duration", "getAnimationTimestamp", "Date", "now", "pauseOffset", "isPaused", "pausedAt", "play", "pause", "internalFrames", "callbackStore", "renderFrame", "renderOutput", "transition", "_i", "keyframes", "transitionOutput", "newInternalFrames", "newFrames", "currentState", "firstShape", "shapeGenerator", "firstShapeCenterPoint", "firstShape_1", "transitionSourceFrameIndex", "isSynthetic", "totalOffset", "prevFrame", "internalFrames_1", "newFrame", "playPause"]
}
